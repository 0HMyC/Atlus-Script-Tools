using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Globalization;
using AtlusScriptLib.Common.Text.OutputProviders;
using AtlusScriptLib.MessageScriptLanguage.Decompiler;
using AtlusScriptLib.MessageScriptLanguage;
using AtlusScriptLib.FlowScriptLanguage.BinaryModel;

namespace AtlusScriptLib.FlowScriptLanguage.Disassembler
{
    public class FlowScriptBinaryDisassembler : IDisposable
    {
        private bool mDisposed;
        private string mHeaderString = "This file was generated by AtlusScriptLib";
        private FlowScriptBinary mScript;
        private ITextOutputProvider mOutput;
        private int mInstructionIndex;

        private FlowScriptBinaryInstruction CurrentInstruction
        {
            get
            {
                if ( mScript == null || mScript.TextSection == null || mScript.TextSection.Count == 0 )
                    throw new InvalidOperationException( "Invalid state" );

                return mScript.TextSection[mInstructionIndex];
            }
        }

        private FlowScriptBinaryInstruction? NextInstruction
        {
            get
            {
                if ( mScript == null || mScript.TextSection == null || mScript.TextSection.Count == 0 )
                    return null;

                if ( ( mInstructionIndex + 1 ) < ( mScript.TextSection.Count - 1 ) )
                    return mScript.TextSection[mInstructionIndex + 1];
                else
                    return null;
            }
        }

        public FlowScriptBinaryDisassembler( StringBuilder stringBuilder )
        {
            mOutput = new StringBuilderTextOutputProvider( stringBuilder );
        }

        public FlowScriptBinaryDisassembler( TextWriter writer )
        {
            mOutput = new TextWriterTextOutputProvider( writer );
        }

        public FlowScriptBinaryDisassembler( string outpath )
        {
            mOutput = new FileTextOutputProvider( outpath );
        }

        public FlowScriptBinaryDisassembler( Stream stream )
        {
            mOutput = new StreamTextOutputProvider( stream );
        }

        public void Disassemble( FlowScriptBinary script )
        {
            mScript = script ?? throw new ArgumentNullException( nameof( script ) );
            mInstructionIndex = 0;

            WriteDisassembly();
        }

        private void WriteCommentLine( string text )
        {
            mOutput.WriteLine( "# " + text );
        }

        private void WriteDisassembly()
        {
            WriteHeader();
            WriteTextDisassembly();

            if ( mScript.MessageScriptSection != null )
                WriteMessageScriptDisassembly();
        }

        private void WriteHeader()
        {
            WriteCommentLine( mHeaderString );
            mOutput.WriteLine();
        }

        private void WriteTextDisassembly()
        {
            mOutput.WriteLine( ".text" );

            while ( mInstructionIndex < mScript.TextSection.Count )
            {
                // Check if there is a possible jump label at the current index
                if ( mScript.JumpLabelSection != null )
                {
                    foreach ( var jump in mScript.JumpLabelSection.Where( x => x.InstructionIndex == mInstructionIndex ) )
                    {
                        mOutput.WriteLine( $"{jump.Name}:" );
                    }
                }

                if ( CurrentInstruction.Opcode == FlowScriptOpcode.PROC )
                    mOutput.WriteLine();

                WriteInstructionDisassembly();

                if ( OpcodeUsesExtendedOperand( CurrentInstruction.Opcode ) )
                {
                    mInstructionIndex += 2;
                }
                else
                {
                    mInstructionIndex += 1;
                }
            }

            mOutput.WriteLine();
        }

        private bool OpcodeUsesExtendedOperand( FlowScriptOpcode opcode )
        {
            return opcode == FlowScriptOpcode.PUSHI || opcode == FlowScriptOpcode.PUSHF;
        }

        private void WriteInstructionDisassembly()
        {
            mOutput.Write( $"# {mInstructionIndex:D4}:{mInstructionIndex:X4} # " );

            switch ( CurrentInstruction.Opcode )
            {
                // extended int operand
                case FlowScriptOpcode.PUSHI:
                    mOutput.Write( DisassembleInstructionWithIntOperand( CurrentInstruction, NextInstruction.Value ) );
                    break;

                // extended float operand
                case FlowScriptOpcode.PUSHF:
                    mOutput.Write( DisassembleInstructionWithFloatOperand( CurrentInstruction, NextInstruction.Value ) );
                    break;

                // short operand
                case FlowScriptOpcode.PUSHIX:
                case FlowScriptOpcode.PUSHIF:
                case FlowScriptOpcode.POPIX:
                case FlowScriptOpcode.POPFX:
                case FlowScriptOpcode.RUN:
                case FlowScriptOpcode.PUSHIS:
                case FlowScriptOpcode.PUSHLIX:
                case FlowScriptOpcode.PUSHLFX:
                case FlowScriptOpcode.POPLIX:
                case FlowScriptOpcode.POPLFX:
                    mOutput.Write( DisassembleInstructionWithShortOperand( CurrentInstruction ) );
                    break;

                // string opcodes
                case FlowScriptOpcode.PUSHSTR:
                    mOutput.Write( DisassembleInstructionWithStringReferenceOperand( CurrentInstruction, mScript.StringSection ) );
                    break;

                // branch procedure opcodes
                case FlowScriptOpcode.PROC:
                    mOutput.Write( DisassembleInstructionWithLabelReferenceOperand( CurrentInstruction, mScript.ProcedureLabelSection ) );
                    break;

                case FlowScriptOpcode.JUMP:
                case FlowScriptOpcode.CALL:
                    mOutput.Write( DisassembleInstructionWithLabelReferenceOperand( CurrentInstruction, mScript.ProcedureLabelSection ) );
                    break;

                // branch jump opcodes                           
                case FlowScriptOpcode.GOTO:
                case FlowScriptOpcode.IF:
                    mOutput.Write( DisassembleInstructionWithLabelReferenceOperand( CurrentInstruction, mScript.JumpLabelSection ) );
                    break;

                // branch communicate opcode
                case FlowScriptOpcode.COMM:
                    mOutput.Write( DisassembleInstructionWithCommReferenceOperand( CurrentInstruction ) );
                    break;

                // No operands
                case FlowScriptOpcode.PUSHREG:
                case FlowScriptOpcode.ADD:
                case FlowScriptOpcode.SUB:
                case FlowScriptOpcode.MUL:
                case FlowScriptOpcode.DIV:
                case FlowScriptOpcode.MINUS:
                case FlowScriptOpcode.NOT:
                case FlowScriptOpcode.OR:
                case FlowScriptOpcode.AND:
                case FlowScriptOpcode.EQ:
                case FlowScriptOpcode.NEQ:
                case FlowScriptOpcode.S:
                case FlowScriptOpcode.L:
                case FlowScriptOpcode.SE:
                case FlowScriptOpcode.LE:
                    mOutput.Write( DisassembleInstructionWithNoOperand( CurrentInstruction ) );
                    break;

                case FlowScriptOpcode.END:
                    mOutput.Write( DisassembleInstructionWithNoOperand( CurrentInstruction ) );
                    break;

                default:
                    throw new InvalidOperationException( $"Unknown opcode {CurrentInstruction.Opcode}" );
            }

            mOutput.WriteLine();
        }

        private void WriteMessageScriptDisassembly()
        {
            mOutput.WriteLine( ".msg" );

            using ( var messageScriptDecompiler = new MessageScriptDecompiler() )
            {
                messageScriptDecompiler.TextOutputProvider = mOutput;
                messageScriptDecompiler.Decompile( MessageScript.FromBinary( mScript.MessageScriptSection ) );
            }
        }

        public static string DisassembleInstructionWithNoOperand( FlowScriptBinaryInstruction instruction )
        {
            if ( instruction.OperandShort != 0 )
            {
                throw new ArgumentOutOfRangeException( nameof( instruction.OperandShort ), $"{instruction.Opcode} should not have any operands" );
            }

            return $"{instruction.Opcode}";
        }

        public static string DisassembleInstructionWithIntOperand( FlowScriptBinaryInstruction instruction, FlowScriptBinaryInstruction operand )
        {
            return $"{instruction.Opcode}\t{operand.OperandInt:X8}";
        }

        public static string DisassembleInstructionWithFloatOperand( FlowScriptBinaryInstruction instruction, FlowScriptBinaryInstruction operand )
        {
            return $"{instruction.Opcode}\t\t{operand.OperandFloat.ToString( "0.00#####", CultureInfo.InvariantCulture )}f";
        }

        public static string DisassembleInstructionWithShortOperand( FlowScriptBinaryInstruction instruction )
        {
            return $"{instruction.Opcode}\t{instruction.OperandShort:X4}";
        }

        public static string DisassembleInstructionWithStringReferenceOperand( FlowScriptBinaryInstruction instruction, IList<byte> stringTable )
        {
            string value = string.Empty;
            for ( int i = instruction.OperandShort; i < stringTable.Count; i++ )
            {
                if ( stringTable[i] == 0 )
                    break;

                value += ( char )stringTable[i];
            }

            return $"{instruction.Opcode}\t\"{value}\"";
        }

        public static string DisassembleInstructionWithLabelReferenceOperand( FlowScriptBinaryInstruction instruction, IList<FlowScriptBinaryLabel> labels )
        {
            if ( instruction.OperandShort >= labels.Count )
            {
                throw new ArgumentOutOfRangeException( nameof( instruction.OperandShort ), $"No label for label reference id {instruction.OperandShort} present in {nameof( labels )}" );
            }

            return $"{instruction.Opcode}\t\t{labels[instruction.OperandShort].Name}";
        }

        public static string DisassembleInstructionWithCommReferenceOperand( FlowScriptBinaryInstruction instruction )
        {
            return $"{instruction.Opcode}\t\t{instruction.OperandShort:X4}";
        }

        public void Dispose()
        {
            Dispose( true );
        }

        protected virtual void Dispose( bool disposing )
        {
            if ( mDisposed )
                return;

            mOutput.Dispose();
            mDisposed = true;
        }
    }
}
