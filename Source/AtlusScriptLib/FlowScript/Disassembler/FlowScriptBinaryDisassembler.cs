using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Globalization;

using AtlusScriptLib.Shared.Utilities;

namespace AtlusScriptLib.FlowScript.Disassembler
{
    public class FlowScriptBinaryDisassembler
    {
        private string m_HeaderString = "This file was generated by AtlusScriptLib";
        private FlowScriptBinary m_Script;
        private IDisassemblerTextOutput m_Output;     
        private int m_InstructionIndex;

        public string HeaderString
        {
            get { return m_HeaderString; }
            set { m_HeaderString = value; }
        }

        private FlowScriptBinaryInstruction CurrentInstruction
        {
            get
            {
                if (m_Script == null || m_Script.TextSectionData == null || m_Script.TextSectionData.Count == 0)
                    throw new InvalidDataException("Invalid state");

                return m_Script.TextSectionData[m_InstructionIndex];
            }
        }

        private FlowScriptBinaryInstruction? NextInstruction
        {
            get
            {
                if (m_Script == null || m_Script.TextSectionData == null || m_Script.TextSectionData.Count == 0)
                    return null;

                if ((m_InstructionIndex + 1) < (m_Script.TextSectionData.Count - 1))
                    return m_Script.TextSectionData[m_InstructionIndex + 1];
                else
                    return null;
            }
        }

        public FlowScriptBinaryDisassembler(StringBuilder stringBuilder)
        {
            m_Output = new StringBuilderDisassemblerTextOutput(stringBuilder);
        }

        public FlowScriptBinaryDisassembler(TextWriter writer)
        {
            m_Output = new TextWriterDisassemblerTextOutput(writer);
        }

        public FlowScriptBinaryDisassembler(string outpath)
        {
            m_Output = new TextWriterDisassemblerTextOutput(new StreamWriter(outpath));
        }

        public FlowScriptBinaryDisassembler(Stream stream)
        {
            m_Output = new TextWriterDisassemblerTextOutput(new StreamWriter(stream));
        }

        public void Disassemble(FlowScriptBinary script)
        {
            m_Script = script ?? throw new ArgumentNullException(nameof(script));
            m_InstructionIndex = 0;

            PutDisassembly();
        }

        private void PutDisassembly()
        {
            PutHeader();
            PutTextDisassembly();
            PutMessageScriptDisassembly();
        }

        private void PutHeader()
        {
            m_Output.PutCommentLine(m_HeaderString);
            m_Output.PutNewline();
        }

        private void PutTextDisassembly()
        {
            m_Output.PutLine(".text");

            while (m_InstructionIndex < m_Script.TextSectionData.Count)
            {
                // Check if there is a possible jump label at the current index
                var jumps = m_Script.JumpLabelSectionData.Where(x => x.Offset == m_InstructionIndex);

                foreach (var jump in jumps)
                {
                    m_Output.PutLine($"{jump.Name}:");
                }

                PutInstructionDisassembly();

                if (OpcodeUsesExtendedOperand(CurrentInstruction.Opcode))
                {
                    m_InstructionIndex += 2;
                }
                else
                {
                    m_InstructionIndex++;
                }
            }

            m_Output.PutNewline();
        }

        private bool OpcodeUsesExtendedOperand(FlowScriptBinaryOpcode opcode)
        {
            if (opcode == FlowScriptBinaryOpcode.PUSHI || opcode == FlowScriptBinaryOpcode.PUSHF)
                return true;

            return false;
        }

        private void PutInstructionDisassembly()
        {
            switch (CurrentInstruction.Opcode)
            {
                // extended int operand
                case FlowScriptBinaryOpcode.PUSHI:
                    m_Output.PutLine(DisassembleInstructionWithIntOperand(CurrentInstruction, NextInstruction.Value));
                    break;

                // extended float operand
                case FlowScriptBinaryOpcode.PUSHF:
                    m_Output.PutLine(DisassembleInstructionWithFloatOperand(CurrentInstruction, NextInstruction.Value));
                    break;

                // short operand
                case FlowScriptBinaryOpcode.PUSHIX:
                case FlowScriptBinaryOpcode.PUSHIF:
                case FlowScriptBinaryOpcode.POPIX:
                case FlowScriptBinaryOpcode.POPFX:
                case FlowScriptBinaryOpcode.RUN:
                case FlowScriptBinaryOpcode.PUSHIS:
                case FlowScriptBinaryOpcode.PUSHLIX:
                case FlowScriptBinaryOpcode.PUSHLFX:
                case FlowScriptBinaryOpcode.POPLIX:
                case FlowScriptBinaryOpcode.POPLFX:
                    m_Output.PutLine(DisassembleInstructionWithShortOperand(CurrentInstruction));
                    break;

                // string opcodes
                case FlowScriptBinaryOpcode.PUSHSTR:
                    m_Output.PutLine(DisassembleInstructionWithStringReferenceOperand(CurrentInstruction, m_Script.StringSectionData));
                    break;

                // branch procedure opcodes
                case FlowScriptBinaryOpcode.PROC:
                case FlowScriptBinaryOpcode.CALL:
                    m_Output.PutLine(DisassembleInstructionWithLabelReferenceOperand(CurrentInstruction, m_Script.ProcedureLabelSectionData));
                    break;

                // branch jump opcodes
                case FlowScriptBinaryOpcode.JUMP:           
                case FlowScriptBinaryOpcode.GOTO:
                case FlowScriptBinaryOpcode.IF:
                    m_Output.PutLine(DisassembleInstructionWithLabelReferenceOperand(CurrentInstruction, m_Script.JumpLabelSectionData));
                    break;

                // branch communicate opcode
                case FlowScriptBinaryOpcode.COMM:
                    m_Output.PutLine(DisassembleInstructionWithCommReferenceOperand(CurrentInstruction));
                    break;

                // No operands
                case FlowScriptBinaryOpcode.PUSHREG:          
                case FlowScriptBinaryOpcode.ADD:
                case FlowScriptBinaryOpcode.SUB:               
                case FlowScriptBinaryOpcode.MUL:
                case FlowScriptBinaryOpcode.DIV:
                case FlowScriptBinaryOpcode.MINUS:
                case FlowScriptBinaryOpcode.NOT:
                case FlowScriptBinaryOpcode.OR:
                case FlowScriptBinaryOpcode.AND:
                case FlowScriptBinaryOpcode.EQ:
                case FlowScriptBinaryOpcode.NEQ:
                case FlowScriptBinaryOpcode.S:
                case FlowScriptBinaryOpcode.L:
                case FlowScriptBinaryOpcode.SE:
                case FlowScriptBinaryOpcode.LE:
                    m_Output.PutLine(DisassembleInstructionWithNoOperand(CurrentInstruction));
                    break;

                case FlowScriptBinaryOpcode.END:
                    m_Output.PutLine(DisassembleInstructionWithNoOperand(CurrentInstruction));
                    if (NextInstruction.HasValue)
                    {
                        if (NextInstruction.Value.Opcode != FlowScriptBinaryOpcode.END)
                            m_Output.PutNewline();
                    }
                    break;

                default:
                    DebugUtils.FatalException($"Unknown opcode {CurrentInstruction.Opcode}");
                    break;
            }
        }

        private void PutMessageScriptDisassembly()
        {
            m_Output.PutLine(".msgdata raw");
            for (int i = 0; i < m_Script.MessageScriptSectionData.Count; i++)
            {
                m_Output.Put(m_Script.MessageScriptSectionData[i].ToString("X2"));
            }
        }

        public static string DisassembleInstructionWithNoOperand(FlowScriptBinaryInstruction instruction)
        {
            if (instruction.OperandShort != 0)
            {
                DebugUtils.TraceError($"{instruction.Opcode} should not have any operands");
            }

            return $"{instruction.Opcode}";
        }

        public static string DisassembleInstructionWithIntOperand(FlowScriptBinaryInstruction instruction, FlowScriptBinaryInstruction operand)
        {
            return $"{instruction.Opcode} {operand.OperandInt}";
        }

        public static string DisassembleInstructionWithFloatOperand(FlowScriptBinaryInstruction instruction, FlowScriptBinaryInstruction operand)
        {
            return $"{instruction.Opcode} {operand.OperandFloat.ToString("0.00#####", CultureInfo.InvariantCulture)}f";
        }

        public static string DisassembleInstructionWithShortOperand(FlowScriptBinaryInstruction instruction)
        {
            return $"{instruction.Opcode} {instruction.OperandShort}";
        }

        public static string DisassembleInstructionWithStringReferenceOperand(FlowScriptBinaryInstruction instruction, IDictionary<int, string> stringMap)
        {
            if (!stringMap.ContainsKey(instruction.OperandShort))
            {
                DebugUtils.FatalException($"No string for string reference id {instruction.OperandShort} present in {nameof(stringMap)}");
            }

            return $"{instruction.Opcode} \"{stringMap[instruction.OperandShort]}\"";
        }

        public static string DisassembleInstructionWithLabelReferenceOperand(FlowScriptBinaryInstruction instruction, IList<FlowScriptBinaryLabel> labels)
        {
            if (instruction.OperandShort >= labels.Count)
            {
                DebugUtils.FatalException($"No label for label reference id {instruction.OperandShort} present in {nameof(labels)}");
            }

            return $"{instruction.Opcode} {labels[instruction.OperandShort].Name}";
        }

        public static string DisassembleInstructionWithCommReferenceOperand(FlowScriptBinaryInstruction instruction)
        {
            return $"{instruction.Opcode} {instruction.OperandShort}";
        }
    }
}
